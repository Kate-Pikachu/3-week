1.  Когда используются контейнеры типа (мульти) множество и отображение?
	1) set - сразу упорядоченное множество; имеет уникальные ключи - при добавлении одинаковых значений, set будет хранить только один его экземпляр
	2) multiset - сразу упорядоченное множество; он хранит повторяющееся элементы, по сравнению с множеством set.
Можно использовать, т.к.: 	 - быстрая сортировка элементов;
			 - если у мало обращений к определенным ячейкам, то точно нужно
			 - есть классный метод erase:
				а) может удалить какой - то конкретный элемент
				б) может удалить все элементы с данным значением. Это отличная функция для мультимножества. А для set мы как раз удалим конкретный элемент, это удобнее чем найти итератор на определенное значение через функции find или lower_bound, а потом его удалить
				в) может удалить определенный диапазон значений.
			- есть классный метод lower_bound: 
				а) проверяет есть ли элемент, который равен определенному ключу, либо больше его
			- есть классный метод upper_bound - этот метод идентичен функции lower_bound:
				а) у него такая же конструкция вызова
				б) при поиске также используется бинарный поиск
				в) ищет элемент, который именно больше ключа
			- есть классный метод find:
				а) находит итератор на элемент, либо проверяет существует ли он вообще.
				б) эта функция может возвратить:
					 - Местонахождение ключа - итератор.
					 - Значение на конец контейнера ( оно будет равняться вызову st.end()), если ячейки с таким значением не существует.
			- есть классный метод count:
				а) возвращает количество элементов с заданным значением.
	3) map - отсортированный ассоциативный контейнер, который содержит пары ключ-значение с неповторяющимися ключами.
Используется для хранения и извлечения данных из коллекции, в которой каждый элемент является парой, обладающей одновременно значением данных и ключом сортировки. Значение ключа уникально и применяется для автоматической сортировки данных.
Значение элемента в сопоставлении можно изменить напрямую. Значение ключа является константой и не может быть изменено. Вместо этого значения ключей, связанные со старыми элементами, необходимо удалить и вставить новые значения ключей для новых элементов.

Контейнеры map и set разрешают вставку только одного экземпляра ключа или элемента. Если необходимо включить несколько экземпляров элемента, следует использовать контейнер multimap или multiset. Неупорядоченные версии этих контейнеров — unordered_multimap и unordered_multiset.


2. Каким требованиям должна удовлетворять качественная хэш - функция?
	1) работает быстро
	2) детерминизм - одинаковые входные и выходные данные
	3) равномерность 
	4) лавинный эффект - помогает при шифровании 
		 - важно, чтобы при малейшем изменении аргумента значение функции сильно изменялось (лавинный эффект). В частности, значение хэша не должно давать утечки информации даже об отдельных битах аргумента.

3. Из-за чего в хэш-таблицах возникают коллизии и как можно их разрешать?

		Ситуация, когда для различных ключей получается одно и то же хеш-значение, называется коллизией.
	Например, если все ключи элементов известны заранее (или очень редко меняются), то для них можно найти некоторую совершенную хеш-функцию, которая распределит их по ячейкам хеш-таблицы без коллизий. Хеш-таблицы, использующие подобные хеш-функции, 
	не нуждаются в механизме разрешения коллизий, и называются хеш-таблицами с прямой адресацией.

Разрешение коллизий:
	- метод цепочек
		Каждая корзина (bucket) независима и имеет своего рода список записей с одинаковым индексом. Время для операций с хэш-таблицами - это время нахождения корзины (bucket) (которое является постоянным) плюс время для операции со списком.
		В хорошей хэш-таблице каждая корзина (bucket) имеет ноль или одну запись, а иногда две или три, но редко больше. Поэтому структуры, которые эффективны во времени и пространстве для этих случаев, являются предпочтительными.

	- Открытая адресация
		Все записи хранятся в самом массиве корзин (buckets). Когда необходимо вставить новую запись, корзины проверяются, начиная с ячейки хэшированного до и продолжаясь в некоторой последовательности проб, до тех пор, пока не будет найден незанятый слот. 
		При поиске записи корзины сканируются в той же последовательности, пока не будет найдена либо целевая запись, либо не найден слот неиспользуемого массива, что указывает на то, что в таблице такого ключа нет. Название "открытая адресация" относится к тому факту, 
		что местоположение ("адрес") элемента не определяется его хэш-значением. 

4. Почему сложность основных операций хэш-таблиц в худшем случае O(N)?

	 - Если слишком много элементов были хэшированы в один и тот же ключ: внутри этой клавиши может потребоваться время O(n).
	 - После того, как хеш-таблица прошла свой баланс нагрузки, он должен перефразировать [создать новую большую таблицу и снова вставить каждый элемент в таблицу].

5. Что позволяет сделать инструмент создания контейнеров Boost. Multiindex?

	 Инструмент создания контейнеров Boost. Multiindex позволяет сделать различные интерфейсы для работы с одим набором данных.




